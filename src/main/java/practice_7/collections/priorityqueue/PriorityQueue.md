## **1️⃣ Разбор в `PriorityQueue`**
### 📌 Что такое `PriorityQueue`?
`PriorityQueue` — это **очередь с приоритетом**, где элементы извлекаются **не по порядку добавления, а по приоритету**.  
Она использует **двоичную кучу (Binary Heap)**, что делает операции **добавления и удаления `O(log n)`, а доступ к минимуму `O(1)`**.

### 📌 **Ключевые особенности `PriorityQueue`:**
✅ **Минимальный элемент выходит первым** (по умолчанию).  
✅ **Основана на двоичной куче** (Binary Heap).  
✅ **Сложность:**
- **`offer()` (добавление) — `O(log n)`**
- **`poll()` (удаление) — `O(log n)`**
- **`peek()` (доступ к минимуму) — `O(1)`**
  ✅ **Не потокобезопасна** (используй `PriorityBlockingQueue` для многопоточности).  
  ✅ **Разрешает дубликаты**.  
  ✅ **Поддерживает `Comparable` и `Comparator`**.

---

## **2️⃣ Как `PriorityQueue` работает под капотом?**
### 📌 Основные структуры:
- Данные хранятся в **массиве `Object[] queue`**, который представляет **двоичную кучу (Binary Heap)**.
- Новый элемент добавляется **в конец массива**, а затем **перемещается вверх (`siftUp()`)**, чтобы восстановить свойство кучи.
- При удалении **корень (минимальный элемент) заменяется последним элементом**, который затем **опускается вниз (`siftDown()`)**.

---

## **3️⃣ Основные методы `PriorityQueue`**
### 📌 1️⃣ **Добавление элемента (`offer()`, `add()`)**
```java
public boolean offer(E e) {
    if (e == null)
        throw new NullPointerException();
    int i = size;
    if (i >= queue.length) // Если массив заполнен, расширяем
        grow(i + 1);
    size = i + 1;
    if (i == 0)
        queue[0] = e;
    else
        siftUp(i, e); // Восстанавливаем кучу
    return true;
}
```
- Добавляет элемент **в конец массива**.
- **Вызывает `siftUp()`**, чтобы поддерживать структуру кучи.

---

### 📌 2️⃣ **Удаление элемента (`poll()`)**
```java
public E poll() {
    if (size == 0)
        return null;
    int s = --size;
    E result = (E) queue[0]; // Забираем минимальный элемент (корень)
    E x = (E) queue[s];
    queue[s] = null;
    if (s != 0)
        siftDown(0, x); // Восстанавливаем кучу
    return result;
}
```
- **Удаляет корень (минимальный элемент)**.
- Последний элемент **заменяет корень** и **перемещается вниз (`siftDown()`)**.

---

### 📌 3️⃣ **Просмотр минимального элемента (`peek()`)**
```java
public E peek() {
    return (size == 0) ? null : (E) queue[0];
}
```
- Просто возвращает **первый элемент массива** (он всегда минимальный).

---

## **4️⃣ Балансировка кучи (`siftUp()` и `siftDown()`)**
### 📌 **Как `siftUp()` восстанавливает кучу при добавлении?**
```java
private void siftUp(int k, E x) {
    while (k > 0) {
        int parent = (k - 1) >>> 1; // Индекс родителя
        E e = (E) queue[parent];
        if (comparator != null ? comparator.compare(x, e) >= 0 : ((Comparable<? super E>) x).compareTo(e) >= 0)
            break;
        queue[k] = e; // Поднимаем родителя вниз
        k = parent;
    }
    queue[k] = x;
}
```
- **Элемент поднимается вверх**, пока **не встретит элемент меньшего значения**.

### 📌 **Как `siftDown()` восстанавливает кучу при удалении?**
```java
private void siftDown(int k, E x) {
    int half = size >>> 1;
    while (k < half) {
        int child = (k << 1) + 1; // Левый потомок
        int right = child + 1;
        if (right < size && comparator.compare((E) queue[child], (E) queue[right]) > 0)
            child = right;
        if (comparator.compare(x, (E) queue[child]) <= 0)
            break;
        queue[k] = queue[child]; // Двигаем ребёнка вверх
        k = child;
    }
    queue[k] = x;
}
```
- **Элемент опускается вниз**, пока **не будет выполнено свойство кучи**.

---

## **5️⃣ Сравнение `PriorityQueue` и `TreeSet`**
| **Функция** | **PriorityQueue** | **TreeSet** |
|------------|----------------|------------|
| Основан на | **Куча (Heap)** | **Красно-чёрное дерево** |
| Вставка | `O(log n)` | `O(log n)` |
| Удаление | `O(log n)` | `O(log n)` |
| Доступ к минимуму | `O(1)` | `O(log n)` |
| Дубликаты | ✅ Разрешены | ❌ Запрещены |
| Сортировка | ❌ Нет | ✅ Да |

---

## **6️⃣ Заключение**
- `PriorityQueue` использует **двоичную кучу (Binary Heap)**.
- Поддерживает **`Comparable` и `Comparator`**.
- **Вставка и удаление `O(log n)`, доступ к минимуму `O(1)`**.
- Не подходит для **отсортированного хранения**, только **для приоритетной обработки**.
- Если нужен **отсортированный порядок**, лучше использовать **`TreeSet`**.

---

